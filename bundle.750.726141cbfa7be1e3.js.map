{"version":3,"file":"bundle.750.726141cbfa7be1e3.js","mappings":"sGAAA,SAASA,EAAQC,GAAwT,OAAtOD,EAArD,mBAAXE,QAAoD,iBAApBA,OAAOC,SAAmC,SAAiBF,GAAO,cAAcA,CAAK,EAAsB,SAAiBA,GAAO,OAAOA,GAAyB,mBAAXC,QAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOG,UAAY,gBAAkBJ,CAAK,EAAYD,EAAQC,EAAM,CAE/U,SAASK,EAAUC,GAChC,OAAc,OAAVA,GAAqC,WAAnBP,EAAQO,IACrBA,GAA+B,mBAAfA,EAAMC,IAIjC,CCAA,SAASC,EAAQC,EAAQC,GAAkB,IAAIC,EAAOC,OAAOD,KAAKF,GAAS,GAAIG,OAAOC,sBAAuB,CAAE,IAAIC,EAAUF,OAAOC,sBAAsBJ,GAAaC,IAAgBI,EAAUA,EAAQC,QAAO,SAAUC,GAAO,OAAOJ,OAAOK,yBAAyBR,EAAQO,GAAKE,UAAY,KAAIP,EAAKQ,KAAKC,MAAMT,EAAMG,EAAU,CAAE,OAAOH,CAAM,CAEpV,SAASU,EAAcC,GAAU,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CAAE,IAAIG,EAAyB,MAAhBF,UAAUD,GAAaC,UAAUD,GAAK,CAAC,EAAOA,EAAI,EAAKf,EAAQI,OAAOc,IAAS,GAAMC,SAAQ,SAAUC,GAAOC,EAAgBP,EAAQM,EAAKF,EAAOE,GAAO,IAAehB,OAAOkB,0BAA6BlB,OAAOmB,iBAAiBT,EAAQV,OAAOkB,0BAA0BJ,IAAmBlB,EAAQI,OAAOc,IAASC,SAAQ,SAAUC,GAAOhB,OAAOoB,eAAeV,EAAQM,EAAKhB,OAAOK,yBAAyBS,EAAQE,GAAO,GAAM,CAAE,OAAON,CAAQ,CAErhB,SAASO,EAAgB7B,EAAK4B,EAAKtB,GAAiK,OAApJsB,KAAO5B,EAAOY,OAAOoB,eAAehC,EAAK4B,EAAK,CAAEtB,MAAOA,EAAOY,YAAY,EAAMe,cAAc,EAAMC,UAAU,IAAkBlC,EAAI4B,GAAOtB,EAAgBN,CAAK,C,mEAQzM,IAAImC,EAAa,CACtBC,QAAS,UACTC,UAAW,YACXC,SAAU,YAQL,SAASC,IACd,IAAIC,EAAShB,UAAUC,OAAS,QAAsBgB,IAAjBjB,UAAU,GAAmBA,UAAU,GAAK,CAAC,EAC9EkB,EAAe,CAACP,EAAWC,QAASD,EAAWE,UAAWF,EAAWG,UACrEK,EAAwBH,EAAOI,qBAAuBF,EACtDG,OAAyDJ,IAAhCD,EAAOM,qBAAqC,IAAMN,EAAOM,qBACtF,OAAO,SAAUC,GACf,IAAIC,EAAWD,EAAIC,SACnB,OAAO,SAAUC,GACf,OAAO,SAAUC,GAMf,IAAIC,EACAC,EAaJ,IAAIF,EAAOG,QA0BT,OAAOJ,EAAKC,GAzBZ,IAAII,EAAUJ,EAAOG,QAErB,GAAIhD,EAAUiD,GACZH,EAAUG,OAEP,GAAIjD,EAAUiD,EAAQH,SACvBA,EAAUG,EAAQH,QAClBC,EAAOE,EAAQF,SAEZ,IAAuB,mBAAZE,GAAqD,mBAApBA,EAAQH,QAYnD,OAAOF,EAAKC,GARd,GAHAC,EAAUG,EAAQH,QAAUG,EAAQH,UAAYG,IAChDF,EAAOE,EAAQH,QAAUG,EAAQF,UAAOX,GAEnCpC,EAAU8C,GAEb,OAAOF,EAAK5B,EAAc,CAAC,EAAG6B,EAAQ,CACpCG,QAASF,IAMb,CAYR,IA9FgBI,EAAKhC,EA8FjBiC,EAAON,EAAOO,KACdC,EAAOR,EAAOS,KAMdC,GArGiBrC,EAqG6C,EA/F1E,SAAyBgC,GAAO,GAAIM,MAAMC,QAAQP,GAAM,OAAOA,CAAK,CAN3BQ,CAAjBR,EAqG2BZ,IAjGnD,SAA+BY,EAAKhC,GAAK,GAAMtB,OAAOC,YAAYU,OAAO2C,IAAgD,uBAAxC3C,OAAOR,UAAU4D,SAASC,KAAKV,GAAvE,CAAmH,IAAIW,EAAO,GAAQC,GAAK,EAAUC,GAAK,EAAWC,OAAK5B,EAAW,IAAM,IAAK,IAAiC6B,EAA7BC,EAAKhB,EAAItD,OAAOC,cAAmBiE,GAAMG,EAAKC,EAAGtB,QAAQuB,QAAoBN,EAAK/C,KAAKmD,EAAGhE,QAAYiB,GAAK2C,EAAKzC,SAAWF,GAA3D4C,GAAK,GAAkE,CAAE,MAAOM,GAAOL,GAAK,EAAMC,EAAKI,CAAK,CAAE,QAAU,IAAWN,GAAsB,MAAhBI,EAAW,QAAWA,EAAW,QAAK,CAAE,QAAU,GAAIH,EAAI,MAAMC,CAAI,CAAE,CAAE,OAAOH,CAA3W,CAAiX,CAJ1cQ,CAAsBnB,EAAKhC,IAE5F,WAA8B,MAAM,IAAIoD,UAAU,uDAAyD,CAFTC,IAsGtFC,EAAUjB,EAAsB,GAChCkB,EAAYlB,EAAsB,GAClCmB,EAAWnB,EAAsB,GA0BjCoB,EAAY,SAAmBC,EAAYC,GAC7C,OAAO7D,EAAc,CAEnBoC,KAAM,CAACD,EAAM0B,EAAaH,EAAWD,GAAWK,KAAKtC,IACpDoC,QAA2D,CAAC,EAAI,CACjE5B,QAAS4B,GACR,CAAC,OAAYxC,IAATiB,EAAqB,CAC1BC,KAAMD,GACJ,CAAC,EAAG,CAAC,EAAGwB,EAAa,CACvBE,OAAO,GACL,CAAC,EACP,EAsDA,OAbAnC,EAAK5B,EAAc,CAEjBoC,KAAM,CAACD,EAAMqB,GAASM,KAAKtC,SACjBJ,IAATW,EAAqB,CACtBC,QAASD,GACP,CAAC,EAAG,CAAC,OAAYX,IAATiB,EAAqB,CAC/BC,KAAMD,GACJ,CAAC,IAMEP,EAAQ5C,MA7BK,WAClB,IAAID,EAAQkB,UAAUC,OAAS,QAAsBgB,IAAjBjB,UAAU,GAAmBA,UAAU,GAAK,KAC5E6D,EAAiBL,EAAU1E,GAAO,GAEtC,OADA0C,EAASqC,GACF,CACL/E,MAAOA,EACP4C,OAAQmC,EAEZ,IAtBmB,SAAsBC,GACvC,IAAIC,EAAiBP,EAAUM,GAAQ,GAEvC,MADAtC,EAASuC,GACHD,CACR,GAwCF,CACF,CACF,CACF,CACe,SAASE,IACtB,IACIxC,GADOxB,UAAUC,OAAS,QAAsBgB,IAAjBjB,UAAU,GAAmBA,UAAU,GAAK,CAAC,GAC5DwB,SAEpB,MAAwB,mBAAbA,EACFT,IAAgB,CACrBS,SAAUA,IASP,IACT,C","sources":["webpack://openshift/./node_modules/redux-promise-middleware/dist/es/isPromise.js","webpack://openshift/./node_modules/redux-promise-middleware/dist/es/index.js"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexport default function isPromise(value) {\n  if (value !== null && _typeof(value) === 'object') {\n    return value && typeof value.then === 'function';\n  }\n\n  return false;\n}","function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport isPromise from './isPromise.js';\n/**\n * For TypeScript support: Remember to check and make sure\n * that `index.d.ts` is also up to date with the implementation.\n */\n\nexport var ActionType = {\n  Pending: 'PENDING',\n  Fulfilled: 'FULFILLED',\n  Rejected: 'REJECTED'\n};\n/**\n * Function: createPromise\n * Description: The main createPromise accepts a configuration\n * object and returns the middleware.\n */\n\nexport function createPromise() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultTypes = [ActionType.Pending, ActionType.Fulfilled, ActionType.Rejected];\n  var PROMISE_TYPE_SUFFIXES = config.promiseTypeSuffixes || defaultTypes;\n  var PROMISE_TYPE_DELIMITER = config.promiseTypeDelimiter === undefined ? '_' : config.promiseTypeDelimiter;\n  return function (ref) {\n    var dispatch = ref.dispatch;\n    return function (next) {\n      return function (action) {\n        /**\n         * Instantiate variables to hold:\n         * (1) the promise\n         * (2) the data for optimistic updates\n         */\n        var promise;\n        var data;\n        /**\n         * There are multiple ways to dispatch a promise. The first step is to\n         * determine if the promise is defined:\n         * (a) explicitly (action.payload.promise is the promise)\n         * (b) implicitly (action.payload is the promise)\n         * (c) as an async function (returns a promise when called)\n         *\n         * If the promise is not defined in one of these three ways, we don't do\n         * anything and move on to the next middleware in the middleware chain.\n         */\n        // Step 1a: Is there a payload?\n\n        if (action.payload) {\n          var PAYLOAD = action.payload; // Step 1.1: Is the promise implicitly defined?\n\n          if (isPromise(PAYLOAD)) {\n            promise = PAYLOAD;\n          } // Step 1.2: Is the promise explicitly defined?\n          else if (isPromise(PAYLOAD.promise)) {\n              promise = PAYLOAD.promise;\n              data = PAYLOAD.data;\n            } // Step 1.3: Is the promise returned by an async function?\n            else if (typeof PAYLOAD === 'function' || typeof PAYLOAD.promise === 'function') {\n                promise = PAYLOAD.promise ? PAYLOAD.promise() : PAYLOAD();\n                data = PAYLOAD.promise ? PAYLOAD.data : undefined; // Step 1.3.1: Is the return of action.payload a promise?\n\n                if (!isPromise(promise)) {\n                  // If not, move on to the next middleware.\n                  return next(_objectSpread({}, action, {\n                    payload: promise\n                  }));\n                }\n              } // Step 1.4: If there's no promise, move on to the next middleware.\n              else {\n                  return next(action);\n                } // Step 1b: If there's no payload, move on to the next middleware.\n\n        } else {\n          return next(action);\n        }\n        /**\n         * Instantiate and define constants for:\n         * (1) the action type\n         * (2) the action meta\n         */\n\n\n        var TYPE = action.type;\n        var META = action.meta;\n        /**\n         * Instantiate and define constants for the action type suffixes.\n         * These are appended to the end of the action type.\n         */\n\n        var _PROMISE_TYPE_SUFFIXE = _slicedToArray(PROMISE_TYPE_SUFFIXES, 3),\n            PENDING = _PROMISE_TYPE_SUFFIXE[0],\n            FULFILLED = _PROMISE_TYPE_SUFFIXE[1],\n            REJECTED = _PROMISE_TYPE_SUFFIXE[2];\n        /**\n         * Function: getAction\n         * Description: This function constructs and returns a rejected\n         * or fulfilled action object. The action object is based off the Flux\n         * Standard Action (FSA).\n         *\n         * Given an original action with the type FOO:\n         *\n         * The rejected object model will be:\n         * {\n         *   error: true,\n         *   type: 'FOO_REJECTED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         *\n         * The fulfilled object model will be:\n         * {\n         *   type: 'FOO_FULFILLED',\n         *   payload: ...,\n         *   meta: ... (optional)\n         * }\n         */\n\n\n        var getAction = function getAction(newPayload, isRejected) {\n          return _objectSpread({\n            // Concatenate the type string property.\n            type: [TYPE, isRejected ? REJECTED : FULFILLED].join(PROMISE_TYPE_DELIMITER)\n          }, newPayload === null || typeof newPayload === 'undefined' ? {} : {\n            payload: newPayload\n          }, {}, META !== undefined ? {\n            meta: META\n          } : {}, {}, isRejected ? {\n            error: true\n          } : {});\n        };\n        /**\n         * Function: handleReject\n         * Calls: getAction to construct the rejected action\n         * Description: This function dispatches the rejected action and returns\n         * the original Error object. Please note the developer is responsible\n         * for constructing and throwing an Error object. The middleware does not\n         * construct any Errors.\n         */\n\n\n        var handleReject = function handleReject(reason) {\n          var rejectedAction = getAction(reason, true);\n          dispatch(rejectedAction);\n          throw reason;\n        };\n        /**\n         * Function: handleFulfill\n         * Calls: getAction to construct the fullfilled action\n         * Description: This function dispatches the fulfilled action and\n         * returns the success object. The success object should\n         * contain the value and the dispatched action.\n         */\n\n\n        var handleFulfill = function handleFulfill() {\n          var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n          var resolvedAction = getAction(value, false);\n          dispatch(resolvedAction);\n          return {\n            value: value,\n            action: resolvedAction\n          };\n        };\n        /**\n         * First, dispatch the pending action:\n         * This object describes the pending state of a promise and will include\n         * any data (for optimistic updates) and/or meta from the original action.\n         */\n\n\n        next(_objectSpread({\n          // Concatenate the type string.\n          type: [TYPE, PENDING].join(PROMISE_TYPE_DELIMITER)\n        }, data !== undefined ? {\n          payload: data\n        } : {}, {}, META !== undefined ? {\n          meta: META\n        } : {}));\n        /**\n         * Second, dispatch a rejected or fulfilled action and move on to the\n         * next middleware.\n         */\n\n        return promise.then(handleFulfill, handleReject);\n      };\n    };\n  };\n}\nexport default function middleware() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      dispatch = _ref.dispatch;\n\n  if (typeof dispatch === 'function') {\n    return createPromise()({\n      dispatch: dispatch\n    });\n  }\n\n  if (process && process.env && process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line no-console\n    console.warn(\"Redux Promise Middleware: As of version 6.0.0, the middleware library supports both preconfigured and custom configured middleware. To use a custom configuration, use the \\\"createPromise\\\" export and call this function with your configuration property. To use a preconfiguration, use the default export. For more help, check the upgrading guide: https://docs.psb.design/redux-promise-middleware/upgrade-guides/v6\\n\\nFor custom configuration:\\nimport { createPromise } from 'redux-promise-middleware';\\nconst promise = createPromise({ promiseTypeSuffixes: ['LOADING', 'SUCCESS', 'ERROR'] });\\napplyMiddleware(promise);\\n\\nFor preconfiguration:\\nimport promise from 'redux-promise-middleware';\\napplyMiddleware(promise);\\n    \");\n  }\n\n  return null;\n}"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","isPromise","value","then","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","configurable","writable","ActionType","Pending","Fulfilled","Rejected","createPromise","config","undefined","defaultTypes","PROMISE_TYPE_SUFFIXES","promiseTypeSuffixes","PROMISE_TYPE_DELIMITER","promiseTypeDelimiter","ref","dispatch","next","action","promise","data","payload","PAYLOAD","arr","TYPE","type","META","meta","_PROMISE_TYPE_SUFFIXE","Array","isArray","_arrayWithHoles","toString","call","_arr","_n","_d","_e","_s","_i","done","err","_iterableToArrayLimit","TypeError","_nonIterableRest","PENDING","FULFILLED","REJECTED","getAction","newPayload","isRejected","join","error","resolvedAction","reason","rejectedAction","middleware"],"sourceRoot":""}